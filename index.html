<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ì¹˜ì•„ ìš©ì‚¬ ìë™ ì‚¬ëƒ¥ RPG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #e0f7ff;
    }
    h1 {
      text-align: center;
      margin: 10px 0 4px;
      color: #0f766e;
      font-size: 20px;
    }
    #ui {
      max-width: 640px;
      margin: 0 auto;
      padding: 0 10px 8px;
    }
    #statsTop {
      display: flex;
      justify-content: space-between;
      gap: 4px;
      font-size: 11px;
      background: #f9fafb;
      border-radius: 8px;
      padding: 6px 8px;
      margin-bottom: 4px;
      flex-wrap: wrap;
    }
    #statsTop span { white-space: nowrap; }
    #statsBottom {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      margin-bottom: 4px;
      padding: 0 2px;
      flex-wrap: wrap;
      gap: 4px;
    }
    #message {
      text-align: center;
      font-size: 12px;
      min-height: 18px;
      margin-bottom: 4px;
      color: #111827;
    }
    /* ë¡œê³  ì˜ì—­ */
    #logoBar {
      max-width: 640px;
      margin: 0 auto 4px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #logoBar .logo {
      background: #ffffff;
      border-radius: 999px;
      padding: 4px 10px;
      box-shadow: 0 2px 6px rgba(15,23,42,0.15);
      font-size: 13px;
      font-weight: 700;
      color: #0f172a;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    #logoBar .logo span.icon {
      font-size: 16px;
    }

    #game {
      position: relative;
      width: 100%;
      max-width: 640px;
      margin: 0 auto;
      background:
        repeating-linear-gradient(
          -10deg,
          rgba(255,255,255,0.35) 0px,
          rgba(255,255,255,0.35) 6px,
          rgba(255,255,255,0) 12px
        ),
        linear-gradient(to top, #4db6ac 22%, #b3e9ff 22%);
      background-size: 80px 80px, 100% 100%;
      background-repeat: repeat, no-repeat;
      border-radius: 10px;
      overflow: hidden;
      height: 260px;
      background-position: 0 0, 0 0;
    }
    .ground {
      position: absolute;
      left: 0;
      bottom: 0;
      width: 100%;
      height: 22%;
      background: transparent;
    }
    .entity {
      position: absolute;
      line-height: 1;
      user-select: none;
    }
    .player { font-size: 56px; }
    .enemy { font-size: 44px; }
    .enemy.boss {
      font-size: 60px;
      text-shadow: 0 0 6px rgba(0,0,0,0.4);
    }
    .projectile { font-size: 22px; }

    .hp-bar {
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      bottom:58px;
      width:40px;
      height:5px;
      background:#fecaca;
      border-radius:3px;
      overflow:hidden;
    }
    .hp-fill {
      height:100%;
      width:100%;
      background:#22c55e;
    }
    .float-text {
      position:absolute;
      font-size:11px;
      font-weight:700;
      color:#dc2626;
      pointer-events:none;
      animation: floatUp 0.7s ease-out forwards;
      text-shadow:0 0 2px #fff;
    }
    .float-text.crit { color:#e11d48; }
    .float-text.heal { color:#16a34a; }
    @keyframes floatUp {
      0% { opacity:1; transform: translate(-50%,0); }
      100% { opacity:0; transform: translate(-50%,-24px); }
    }

    #buttons {
      max-width:640px;
      margin: 6px auto 12px;
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      justify-content:center;
      padding:0 10px;
    }
    button {
      border:none;
      border-radius:999px;
      padding:6px 10px;
      font-size:11px;
      font-weight:600;
      cursor:pointer;
      color:#fff;
      box-shadow:0 2px 4px rgba(15,23,42,0.15);
      white-space:nowrap;
    }
    #btnWeapon { background:#3b82f6; }
    #btnArmor  { background:#16a34a; }
    #btnShield { background:#0ea5e9; }
    #btnFluoride { background:#a855f7; }
    #btnFluorideCd { background:#f97316; }
    #btnSkill  { background:#6366f1; }
    #btnPause  { background:#6b7280; }
    button:disabled {
      opacity:0.55;
      cursor:default;
      box-shadow:none;
    }
    /* ë³´ìŠ¤ ì‚¬ë§ì‹œ í™”ë©´ í”Œë˜ì‹œ */
    #flashOverlay {
      position:absolute;
      left:0;
      top:0;
      width:100%;
      height:100%;
      background:white;
      opacity:0;
      pointer-events:none;
      transition: opacity 0.12s ease-out;
    }

    /* ê²Œì„ì˜¤ë²„ ì˜¤ë²„ë ˆì´ */
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }
    .hidden { display: none; }
    .gameover-box {
      background: #ffffff;
      border-radius: 14px;
      padding: 18px 16px;
      max-width: 260px;
      width: 80%;
      text-align: center;
      box-shadow: 0 10px 25px rgba(15,23,42,0.35);
      font-size: 13px;
    }
    .gameover-title {
      font-size: 16px;
      font-weight: 800;
      margin-bottom: 6px;
      color: #b91c1c;
    }
    .gameover-text {
      margin-bottom: 12px;
      color: #111827;
    }
    .gameover-btn {
      border: none;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 700;
      margin: 2px 4px;
      cursor: pointer;
    }
    .gameover-btn.main {
      background: #ef4444;
      color: #fff;
    }
    .gameover-btn.sub {
      background: #e5e7eb;
      color: #111827;
    }
  </style>
</head>
<body>
  <h1>ğŸ¦· ì¹˜ì•„ ìš©ì‚¬ ìë™ ì‚¬ëƒ¥ RPG âš”ï¸</h1>

  <!-- ë‹¤ë´„ì¹˜ê³¼ ë¡œê³ ë°” -->
  <div id="logoBar">
    <div class="logo">
      <span class="icon">ğŸ¥</span>
      <span>ë‹¤ë´„ì¹˜ê³¼ Â· ì¹˜ì•„ ìš©ì‚¬ RPG</span>
    </div>
  </div>

  <div id="ui">
    <div id="statsTop">
      <span>HP: <span id="hpText">100</span> / <span id="hpMaxText">100</span></span>
      <span>ATK: <span id="atkText">10</span></span>
      <span>ê³¨ë“œ: <span id="goldText">0</span></span>
      <span>ê±°ë¦¬: <span id="distText">0</span> m</span>
    </div>
    <div id="statsBottom">
      <span>ìŠ¤í…Œì´ì§€: <span id="stageText">1</span></span>
      <span>ë¬´ê¸° LV: <span id="weaponLvText">1</span></span>
      <span>ë°©ì–´ LV: <span id="armorLvText">1</span></span>
      <span>ë¶ˆì†Œ LV: <span id="fluorideLvText">1</span></span>
      <span>ë¶ˆì†Œì¿¨ LV: <span id="fluorideCdLvText">1</span></span>
      <span>ìŠ¤í‚¬ ì¿¨: <span id="skillCdText">ì¤€ë¹„</span></span>
    </div>
    <div id="message">í™”ë©´ì„ í•œ ë²ˆ íƒ­í•˜ë©´ ì†Œë¦¬ê°€ ì¼œì§‘ë‹ˆë‹¤ ğŸµ</div>
  </div>

  <div id="game">
    <div class="ground"></div>
    <div id="flashOverlay"></div>
  </div>

  <!-- ê²Œì„ì˜¤ë²„ ì˜¤ë²„ë ˆì´ -->
  <div id="gameOverOverlay" class="overlay hidden">
    <div class="gameover-box">
      <div class="gameover-title">â˜  ê²Œì„ ì˜¤ë²„</div>
      <div class="gameover-text">
        ë‹¤ì‹œ ë„ì „í•´ë³¼ê¹Œìš”?
      </div>
      <button class="gameover-btn main" onclick="restartGame()">
        ğŸ” ìƒˆë¡œ í•˜ê¸°
      </button>
      <button class="gameover-btn sub" onclick="closeGameOver()">
        ê·¸ëƒ¥ ë‘˜ë˜
      </button>
    </div>
  </div>

  <div id="buttons">
    <button id="btnWeapon">ğŸª¥ ë¬´ê¸° ê°•í™”</button>
    <button id="btnArmor">ğŸ§´ ë°©ì–´ ê°•í™”</button>
    <button id="btnShield">ğŸ§µ ë°©íŒ¨ ê°•í™”</button>
    <button id="btnFluoride">ğŸ’¥ ë¶ˆì†Œ ë ˆë²¨ì—…</button>
    <button id="btnFluorideCd">â± ì¿¨íƒ€ì„ ì—…</button>
    <button id="btnSkill">ğŸ’¥ ë¶ˆì†Œ í­ë°œ</button>
    <button id="btnPause">â¸ ì¼ì‹œì •ì§€</button>
  </div>

  <script>
    const game = document.getElementById("game");
    const flashOverlay = document.getElementById("flashOverlay");
    const gameOverOverlay = document.getElementById("gameOverOverlay");

    const hpText = document.getElementById("hpText");
    const hpMaxText = document.getElementById("hpMaxText");
    const atkText  = document.getElementById("atkText");
    const goldText = document.getElementById("goldText");
    const distText = document.getElementById("distText");
    const stageText = document.getElementById("stageText");
    const weaponLvText = document.getElementById("weaponLvText");
    const armorLvText  = document.getElementById("armorLvText");
    const fluorideLvText = document.getElementById("fluorideLvText");
    const fluorideCdLvText = document.getElementById("fluorideCdLvText");
    const skillCdText  = document.getElementById("skillCdText");
    const message  = document.getElementById("message");

    const btnWeapon = document.getElementById("btnWeapon");
    const btnArmor  = document.getElementById("btnArmor");
    const btnShield = document.getElementById("btnShield");
    const btnFluoride = document.getElementById("btnFluoride");
    const btnFluorideCd = document.getElementById("btnFluorideCd");
    const btnSkill  = document.getElementById("btnSkill");
    const btnPause  = document.getElementById("btnPause");

    const GROUND_HEIGHT_RATIO = 0.22;
    const TICK = 40; // ms
    const PLAYER_X = 40;

    let running = true;

    const player = {
      x: PLAYER_X,
      y: 0,
      hp: 100,
      maxHp: 100,
      atk: 10,
      def: 0,
      critChance: 0.12,
      critMult: 1.8,
      atkDelay: 380,
      lastAtk: 0,
      el: null,
      hpBar: null,
      hpFill: null
    };

    // ì¥ë¹„/ë ˆë²¨ ì‹œìŠ¤í…œ
    let weaponLevel = 1;
    let armorLevel  = 1;
    let shieldLevel = 1;
    let fluorideLevel = 1;
    let fluorideCooldownLevel = 1; // 1~10

    let distance = 0;
    let gold = 0;
    let stage = 1;

    let enemies = [];
    let projectiles = [];

    let lastSpawn = 0;
    let spawnDelay = 1200;

    let nextBossDist = 150;
    let bossAlive = false;

    let skillCooldownMs = 0;

    let bgOffset = 0;

    // --- ì‚¬ìš´ë“œ ë§¤ë‹ˆì € ---
    class SoundManager {
      constructor() {
        this.ctx = null;
        this.bgmOn = false;
      }
      init() {
        if (this.ctx) return;
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        if (!AudioCtx) return;
        this.ctx = new AudioCtx();
      }
      resume() {
        if (this.ctx && this.ctx.state === "suspended") {
          this.ctx.resume();
        }
      }
      playTone(freq, duration, volume=0.25, type="sine") {
        if (!this.ctx) return;
        const ctx = this.ctx;
        const now = ctx.currentTime;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(volume, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(now);
        osc.stop(now + duration + 0.05);
      }
      playAttack() {
        this.playTone(880, 0.06, 0.10, "square");
      }
      playCrit() {
        this.playTone(1200, 0.12, 0.16, "square");
      }
      playHit() {
        this.playTone(220, 0.07, 0.18, "sawtooth");
      }
      playLevelUp() {
        if (!this.ctx) return;
        this.playTone(660, 0.12, 0.18, "triangle");
        setTimeout(()=>this.playTone(880,0.16,0.2,"triangle"), 130);
      }
      playSkill() {
        if (!this.ctx) return;
        const ctx = this.ctx;
        const now = ctx.currentTime;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = "sawtooth";
        osc.frequency.setValueAtTime(900, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.4);
        gain.gain.setValueAtTime(0.25, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(now);
        osc.stop(now + 0.45);
      }
      playBossDeath() {
        if (!this.ctx) return;
        this.playTone(440,0.2,0.2,"triangle");
        setTimeout(()=>this.playTone(660,0.2,0.2,"triangle"), 150);
        setTimeout(()=>this.playTone(880,0.25,0.22,"triangle"), 320);
      }
      startBgm() {
        if (this.bgmOn || !this.ctx) return;
        this.bgmOn = true;
        const loop = () => {
          if (!this.bgmOn || !this.ctx) return;
          this.playTone(392, 0.5, 0.04, "sine");
          setTimeout(()=>this.playTone(523.25,0.5,0.04,"sine"), 650);
          setTimeout(()=>this.playTone(659.25,0.5,0.04,"sine"), 1300);
          setTimeout(loop, 2200);
        };
        loop();
      }
      startOnFirstTouch() {
        this.init();
        if (!this.ctx) return;
        this.resume();
        this.startBgm();
      }
    }
    const sound = new SoundManager();
    let audioStarted = false;

    function ensureAudio() {
      if (!audioStarted) {
        audioStarted = true;
        sound.startOnFirstTouch();
        message.textContent = "ì†Œë¦¬ê°€ ì¼œì¡ŒìŠµë‹ˆë‹¤ ğŸ”Š";
      } else {
        sound.resume();
      }
    }

    window.addEventListener("pointerdown", ensureAudio, { once:true });

    // ë°œì‚¬ì²´ ìŠ¤íƒ€ì¼ (ë¬´ê¸° ë ˆë²¨ ê¸°ë°˜, 10ë ˆë²¨ë§ˆë‹¤ ë³€í™”)
    const PROJECTILE_STYLES = [
      { ch: "Â·",  size:14, color:"#facc15" }, // 1~10
      { ch: "â€¢",  size:16, color:"#facc15" }, // 11~20
      { ch: "âœ¦", size:18, color:"#fbbf24" }, // 21~30
      { ch: "âœ¸", size:20, color:"#f97316" }, // 31~40
      { ch: "âœ¨", size:22, color:"#f97316" }, // 41~50
      { ch: "ğŸ’¥", size:22, color:"#fb7185" }, // 51~60
      { ch: "ğŸŒŸ", size:22, color:"#a855f7" }, // 61~70
      { ch: "ğŸ’«", size:24, color:"#22c55e" }, // 71~80
      { ch: "ğŸŒˆ", size:24, color:"#38bdf8" }, // 81~90
      { ch: "â˜„ï¸", size:26, color:"#0ea5e9" }  // 91~100
    ];
    function getProjectileStyle() {
      const idx = Math.min(9, Math.floor((weaponLevel - 1) / 10));
      return PROJECTILE_STYLES[idx];
    }

    function createPlayer() {
      const h = game.clientHeight;
      const groundTop = h * (1 - GROUND_HEIGHT_RATIO);
      player.y = groundTop - 72;

      const el = document.createElement("div");
      el.className = "entity player";
      el.textContent = "ğŸ¦·";
      game.appendChild(el);
      player.el = el;

      const bar = document.createElement("div");
      bar.className = "hp-bar";
      const fill = document.createElement("div");
      fill.className = "hp-fill";
      bar.appendChild(fill);
      game.appendChild(bar);
      player.hpBar = bar;
      player.hpFill = fill;

      drawPlayer();
      updateUI();
    }

    function drawPlayer() {
      if (!player.el) return;
      player.el.style.left = player.x + "px";
      player.el.style.top  = player.y + "px";
      if (player.hpBar) {
        player.hpBar.style.left = (player.x + 30) + "px";
        player.hpBar.style.top  = (player.y - 10) + "px";
        const ratio = Math.max(0, player.hp / player.maxHp);
        player.hpFill.style.width = (ratio * 100) + "%";
      }
    }

    const ENEMY_TYPES = [
      {name:"í”Œë¼í¬ê· ", emoji:"ğŸ¦ ", baseHp:40,  speed:1.2, dmg:5,  gold:15, exp:12},
      {name:"ìš°ì‹ê· ",   emoji:"ğŸ§«", baseHp:70,  speed:0.9, dmg:8,  gold:22, exp:18},
      {name:"ì¹˜ì„ê´´ë¬¼", emoji:"ğŸª¨", baseHp:120, speed:0.7, dmg:10, gold:35, exp:30},
      {name:"ë‚ ì•„ë‹¤ë‹ˆëŠ”ê· ", emoji:"ğŸ¦Ÿ", baseHp:55, speed:1.6, dmg:7, gold:18, exp:14}
    ];

    function pickEnemyType() {
      if (stage <= 2) return ENEMY_TYPES[0];
      if (stage === 3) return Math.random() < 0.5 ? ENEMY_TYPES[0] : ENEMY_TYPES[1];
      if (stage === 4) {
        const r = Math.random();
        if (r < 0.4) return ENEMY_TYPES[0];
        if (r < 0.8) return ENEMY_TYPES[1];
        return ENEMY_TYPES[2];
      }
      const r = Math.random();
      if (r < 0.25) return ENEMY_TYPES[0];
      if (r < 0.5) return ENEMY_TYPES[1];
      if (r < 0.75) return ENEMY_TYPES[2];
      return ENEMY_TYPES[3];
    }

    function spawnEnemy(isBoss=false) {
      const h = game.clientHeight;
      const groundTop = h * (1 - GROUND_HEIGHT_RATIO);
      const baseX = game.clientWidth - 60;

      let enemy;
      if (isBoss) {
        const bossHp = 280 + stage * 80;
        enemy = {
          name:"ê±°ëŒ€ ì¶©ì¹˜ ê´´ìˆ˜",
          emoji:"ğŸ‘¾",
          x: baseX,
          y: groundTop - 90,
          hp: bossHp,
          maxHp: bossHp,
          speed: 0.6 + stage*0.02,
          dmg: 18 + stage * 3,
          gold: 180 + stage*30,
          exp: 80 + stage*20,
          boss:true,
          el:null, hpBar:null, hpFill:null
        };
      } else {
        const t = pickEnemyType();
        const hpScale = 1 + (stage-1)*0.3;
        enemy = {
          name:t.name,
          emoji:t.emoji,
          x: baseX,
          y: groundTop - 60,
          hp: Math.round(t.baseHp * hpScale),
          maxHp: Math.round(t.baseHp * hpScale),
          speed: t.speed + (stage-1)*0.05,
          dmg: t.dmg + (stage-1),
          gold: t.gold + stage*2,
          exp: t.exp + stage*3,
          boss:false,
          el:null, hpBar:null, hpFill:null
        };
      }

      const el = document.createElement("div");
      el.className = "entity enemy" + (enemy.boss ? " boss" : "");
      el.textContent = enemy.emoji;
      game.appendChild(el);
      enemy.el = el;

      const bar = document.createElement("div");
      bar.className = "hp-bar";
      bar.style.width = enemy.boss ? "70px" : "40px";
      const fill = document.createElement("div");
      fill.className = "hp-fill";
      bar.appendChild(fill);
      game.appendChild(bar);
      enemy.hpBar = bar;
      enemy.hpFill = fill;

      enemies.push(enemy);
      drawEnemy(enemy);

      if (enemy.boss) {
        bossAlive = true;
        showMessage("âš  ë³´ìŠ¤ ë“±ì¥! " + enemy.name);
      }
    }

    function drawEnemy(e) {
      e.el.style.left = e.x + "px";
      e.el.style.top  = e.y + "px";
      e.hpBar.style.left = (e.x + 24) + "px";
      e.hpBar.style.top  = (e.y - 10) + "px";
      const ratio = Math.max(0, e.hp / e.maxHp);
      e.hpFill.style.width = (ratio * 100) + "%";
    }

    function spawnFloatText(x,y,text,type) {
      const div = document.createElement("div");
      div.className = "float-text" + (type ? " " + type : "");
      div.textContent = text;
      div.style.left = x + "px";
      div.style.top  = y + "px";
      game.appendChild(div);
      setTimeout(()=> {
        if (div.parentNode) div.parentNode.removeChild(div);
      }, 800);
    }

    function shoot() {
      const now = performance.now();
      if (now - player.lastAtk < player.atkDelay) return;
      if (enemies.length === 0) return;

      player.lastAtk = now;
      const projStyle = getProjectileStyle();
      const proj = {
        x: player.x + 38,
        y: player.y + 18,
        speed: 5.2,
        dmg: player.atk,
        el: null
      };
      const el = document.createElement("div");
      el.className = "entity projectile";
      el.textContent = projStyle.ch;
      el.style.fontSize = projStyle.size + "px";
      el.style.color = projStyle.color;
      game.appendChild(el);
      proj.el = el;
      projectiles.push(proj);
      drawProjectile(proj);
      sound.playAttack();
    }

    function drawProjectile(p) {
      if (!p.el) return;
      p.el.style.left = p.x + "px";
      p.el.style.top  = p.y + "px";
    }

    function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    function updateSkillCooldown() {
      if (skillCooldownMs <= 0) {
        skillCooldownMs = 0;
        skillCdText.textContent = "ì¤€ë¹„";
        btnSkill.disabled = false;
      } else {
        skillCooldownMs -= TICK;
        if (skillCooldownMs < 0) skillCooldownMs = 0;
        const sec = Math.ceil(skillCooldownMs/1000);
        skillCdText.textContent = sec + "ì´ˆ";
        btnSkill.disabled = true;
      }
    }

    function getSkillDamage() {
      // ë¶ˆì†Œ ë ˆë²¨ì— ë”°ë¼ ë°°ìˆ˜ ì¦ê°€
      const baseMult = 1.5;
      const addPerLv = 0.3;
      const mult = baseMult + (fluorideLevel - 1) * addPerLv;
      return Math.round(player.atk * mult);
    }

    function getSkillCooldown() {
      const baseSkillCooldown = 18000; // 18ì´ˆ
      const minSkillCooldown  = 2000;  // 2ì´ˆ
      const maxLevel = 10;
      const lvl = Math.min(fluorideCooldownLevel, maxLevel);
      const step = (baseSkillCooldown - minSkillCooldown) / (maxLevel - 1);
      const value = baseSkillCooldown - step * (lvl - 1);
      return Math.max(minSkillCooldown, Math.round(value));
    }

    function updateUI() {
      hpText.textContent = Math.max(0, Math.round(player.hp));
      hpMaxText.textContent = Math.round(player.maxHp);
      atkText.textContent = Math.round(player.atk);
      goldText.textContent = Math.round(gold);
      distText.textContent = Math.floor(distance);
      stageText.textContent = stage;
      weaponLvText.textContent = weaponLevel;
      armorLvText.textContent  = armorLevel;
      fluorideLvText.textContent = fluorideLevel;
      fluorideCdLvText.textContent = fluorideCooldownLevel;

      updateShopButtons();
    }

    function showMessage(text) {
      message.textContent = text;
    }

    function updateStage() {
      const newStage = 1 + Math.floor(distance / 200);
      if (newStage !== stage) {
        stage = newStage;
        showMessage("ğŸ“ˆ ìŠ¤í…Œì´ì§€ " + stage + " ì§„ì…! ì ì´ ë” ê°•í•´ì§‘ë‹ˆë‹¤.");
      }
    }

    function updateBackground() {
      bgOffset -= 0.8;
      game.style.backgroundPosition = `${bgOffset}px 0, 0 0`;
    }

    function removeProjectileAt(index) {
      const p = projectiles[index];
      if (!p) return;
      if (p.el && p.el.parentNode) {
        p.el.parentNode.removeChild(p.el);
      }
      projectiles.splice(index, 1);
    }

    function bossFlashEffect() {
      let count = 0;
      function flashOnce() {
        if (count >= 3) {
          flashOverlay.style.opacity = 0;
          return;
        }
        flashOverlay.style.opacity = 0.9;
        setTimeout(()=>{ flashOverlay.style.opacity = 0; }, 120);
        count++;
        setTimeout(flashOnce, 220);
      }
      flashOnce();
    }

    // ê²Œì„ì˜¤ë²„ + ìƒˆë¡œí•˜ê¸°
    function gameOver() {
      running = false;
      showMessage("â˜  ê²Œì„ ì˜¤ë²„!");
      if (gameOverOverlay) {
        gameOverOverlay.classList.remove("hidden");
      }
    }
    function restartGame() {
      location.reload();
    }
    function closeGameOver() {
      if (gameOverOverlay) {
        gameOverOverlay.classList.add("hidden");
      }
    }
    window.restartGame = restartGame;
    window.closeGameOver = closeGameOver;

    function updateShopButtons() {
      const weaponCost = Math.round(80 * Math.pow(weaponLevel, 1.3));
      const armorCost  = Math.round(80 * Math.pow(armorLevel, 1.3));
      const shieldCost = Math.round(80 * Math.pow(shieldLevel, 1.3));
      const fluorideCost = Math.round(120 * Math.pow(fluorideLevel, 1.4));
      const fluorideCdCost = Math.round(150 * Math.pow(fluorideCooldownLevel, 1.4));

      btnWeapon.textContent = `ğŸª¥ ë¬´ê¸° LV${weaponLevel} / ${weaponCost}G`;
      btnArmor.textContent  = `ğŸ§´ ë°©ì–´ LV${armorLevel} / ${armorCost}G`;
      btnShield.textContent = `ğŸ§µ ë°©íŒ¨ LV${shieldLevel} / ${shieldCost}G`;
      btnFluoride.textContent = `ğŸ’¥ ë¶ˆì†Œ LV${fluorideLevel} / ${fluorideCost}G`;
      btnFluorideCd.textContent = `â± ì¿¨ LV${fluorideCooldownLevel} / ${fluorideCdCost}G`;
      btnSkill.textContent = `ğŸ’¥ ë¶ˆì†Œ í­ë°œ (ë°ë¯¸ì§€ LV${fluorideLevel})`;
    }

    function update() {
      if (!running) return;

      distance += 0.4;
      updateStage();
      updateSkillCooldown();
      updateBackground();

      const now = performance.now();
      if (!bossAlive && distance >= nextBossDist) {
        spawnEnemy(true);
        nextBossDist += 220 + stage*30;
      } else if (!bossAlive && now - lastSpawn > spawnDelay) {
        spawnEnemy(false);
        lastSpawn = now;
        if (spawnDelay > 600) spawnDelay -= 8;
      }

      shoot();

      for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.x += p.speed;
        drawProjectile(p);

        let hit = false;
        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          if (!e.el) continue;
          if (rectsOverlap(p.x, p.y, 20, 20, e.x, e.y, 40, 40)) {
            let dmg = p.dmg;
            let typeTxt = "";
            if (Math.random() < player.critChance) {
              dmg *= player.critMult;
              typeTxt = "crit";
              sound.playCrit();
            } else {
              sound.playHit();
            }
            dmg = Math.round(dmg);
            e.hp -= dmg;
            spawnFloatText(e.x+25, e.y-5, "-" + dmg, typeTxt);

            if (e.hp <= 0) {
              gold += e.gold;
              if (e.boss) {
                bossAlive = false;
                bossFlashEffect();
                sound.playBossDeath();
                spawnFloatText(e.x+25, e.y-5, "CLEAR!", "heal");
              }
              if (e.el && e.el.parentNode) e.el.parentNode.removeChild(e.el);
              if (e.hpBar && e.hpBar.parentNode) e.hpBar.parentNode.removeChild(e.hpBar);
              enemies.splice(j,1);
            } else {
              drawEnemy(e);
            }

            hit = true;
            break;
          }
        }

        if (hit) {
          removeProjectileAt(i);
          continue;
        }
        if (p.x > game.clientWidth + 40) {
          removeProjectileAt(i);
        }
      }

      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        e.x -= e.speed;
        drawEnemy(e);

        if (e.x < player.x + 14) {
          const dmg = Math.max(1, e.dmg - player.def);
          const taken = dmg * 0.08;
          player.hp -= taken;
          spawnFloatText(player.x+30, player.y-5, "-" + Math.round(taken), "");
          sound.playHit();
          if (player.hp <= 0) {
            player.hp = 0;
            updateUI();
            drawPlayer();
            gameOver();
            return;
          }
          drawPlayer();
        }

        if (e.x + 40 < -20) {
          if (e.el && e.el.parentNode) e.el.parentNode.removeChild(e.el);
          if (e.hpBar && e.hpBar.parentNode) e.hpBar.parentNode.removeChild(e.hpBar);
          enemies.splice(i,1);
        }
      }

      updateUI();
    }

    // ìƒì  ë²„íŠ¼ë“¤
    btnWeapon.addEventListener("click", function() {
      const cost = Math.round(80 * Math.pow(weaponLevel, 1.3));
      if (gold < cost) {
        showMessage(`ê³¨ë“œ ë¶€ì¡±! (í•„ìš”: ${cost}G)`);
        return;
      }
      gold -= cost;
      weaponLevel++;
      player.atk += 5 + Math.floor(weaponLevel/2);
      spawnFloatText(player.x+30, player.y-10, "ë¬´ê¸° UP", "heal");
      showMessage(`ë¬´ê¸° LV${weaponLevel} ê°•í™”! ê³µê²©ë ¥ ì¦ê°€`);
      updateUI();
    });

    btnArmor.addEventListener("click", function() {
      const cost = Math.round(80 * Math.pow(armorLevel, 1.3));
      if (gold < cost) {
        showMessage(`ê³¨ë“œ ë¶€ì¡±! (í•„ìš”: ${cost}G)`);
        return;
      }
      gold -= cost;
      armorLevel++;
      const gain = 25 + armorLevel * 2;
      player.maxHp += gain;
      player.hp = player.maxHp;
      spawnFloatText(player.x+30, player.y-10, "ë°©ì–´ UP", "heal");
      showMessage(`ë°©ì–´ LV${armorLevel} ê°•í™”! ìµœëŒ€ HP ì¦ê°€`);
      updateUI();
      drawPlayer();
    });

    btnShield.addEventListener("click", function() {
      const cost = Math.round(80 * Math.pow(shieldLevel, 1.3));
      if (gold < cost) {
        showMessage(`ê³¨ë“œ ë¶€ì¡±! (í•„ìš”: ${cost}G)`);
        return;
      }
      gold -= cost;
      shieldLevel++;
      player.def += 1;
      spawnFloatText(player.x+30, player.y-10, "ë°©íŒ¨ UP", "heal");
      showMessage(`ë°©íŒ¨ LV${shieldLevel} ê°•í™”! ë°ë¯¸ì§€ ê°ì†Œ`);
      updateUI();
    });

    btnFluoride.addEventListener("click", function() {
      const cost = Math.round(120 * Math.pow(fluorideLevel, 1.4));
      if (gold < cost) {
        showMessage(`ê³¨ë“œ ë¶€ì¡±! (í•„ìš”: ${cost}G)`);
        return;
      }
      gold -= cost;
      fluorideLevel++;
      spawnFloatText(player.x+30, player.y-10, "ë¶ˆì†Œ UP", "crit");
      showMessage(`ë¶ˆì†Œ LV${fluorideLevel} ê°•í™”! ìŠ¤í‚¬ ë°ë¯¸ì§€ ì¦ê°€`);
      updateUI();
    });

    btnFluorideCd.addEventListener("click", function() {
      if (fluorideCooldownLevel >= 10) {
        showMessage("ì¿¨íƒ€ì„ LVëŠ” 10ì´ ìµœëŒ€ì…ë‹ˆë‹¤.");
        return;
      }
      const cost = Math.round(150 * Math.pow(fluorideCooldownLevel, 1.4));
      if (gold < cost) {
        showMessage(`ê³¨ë“œ ë¶€ì¡±! (í•„ìš”: ${cost}G)`);
        return;
      }
      gold -= cost;
      fluorideCooldownLevel++;
      spawnFloatText(player.x+30, player.y-10, "ì¿¨íƒ€ì„ UP", "heal");
      showMessage(`ë¶ˆì†Œì¿¨ LV${fluorideCooldownLevel} ê°•í™”! ì¿¨íƒ€ì„ ê°ì†Œ`);
      updateUI();
    });

    btnSkill.addEventListener("click", function() {
      if (skillCooldownMs > 0) return;
      if (enemies.length === 0) {
        showMessage("ê³µê²©í•  ì ì´ ì—†ìŠµë‹ˆë‹¤.");
        return;
      }
      const dmg = getSkillDamage();
      skillCooldownMs = getSkillCooldown();
      showMessage(`ğŸ’¥ ë¶ˆì†Œ í­ë°œ! (ë°ë¯¸ì§€ x${(dmg/player.atk).toFixed(1)})`);
      sound.playSkill();

      enemies.slice().forEach((e) => {
        e.hp -= dmg;
        spawnFloatText(e.x+25, e.y-5, "-" + dmg, "crit");
        if (e.hp <= 0) {
          gold += e.gold;
          if (e.boss) {
            bossAlive = false;
            bossFlashEffect();
            sound.playBossDeath();
          }
          if (e.el && e.el.parentNode) e.el.parentNode.removeChild(e.el);
          if (e.hpBar && e.hpBar.parentNode) e.hpBar.parentNode.removeChild(e.hpBar);
          enemies = enemies.filter(en => en !== e);
        } else {
          drawEnemy(e);
        }
      });
      updateUI();
    });

    btnPause.addEventListener("click", function() {
      running = !running;
      btnPause.textContent = running ? "â¸ ì¼ì‹œì •ì§€" : "â–¶ ë‹¤ì‹œ ì‹œì‘";
      showMessage(running ? "ë‹¤ì‹œ ì „ì§„!" : "ì¼ì‹œì •ì§€ ì¤‘ì…ë‹ˆë‹¤.");
    });

    window.addEventListener("load", function() {
      createPlayer();
      showMessage("í™”ë©´ì„ í•œ ë²ˆ íƒ­í•˜ë©´ ì†Œë¦¬ê°€ ì¼œì§‘ë‹ˆë‹¤ ğŸµ");
      setInterval(update, TICK);
    });
  </script>
</body>
</html>
